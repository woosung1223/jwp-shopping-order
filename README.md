# jwp-shopping-order


<a href = "https://www.notion.so/step2-da784bf6f78b4ce8baa89d489ceb227e"> API 명세 (노션) </a>

# 기능 목록
---

## 기능 목록(API)
- [x] 상품 관련 API
  - [x] 상품 정보는 다음 두 정보까지 포함하도록 개선한다.
    - 포인트 적립비율
    - 포인트 적립 가능여부

- [x] 유저 관련 API
  - [x] 보유한 적립금을 조회할 수 있다.

- [x] 주문 관련 API
  - [x] 장바구니에 담은 상품들을 주문할 수 있다.
  - [x] 사용자별로 주문 목록을 확인할 수 있다.
  - [x] 사용자별로 특정 주문의 상세 정보를 확인할 수 있다.

## 기능 목록(Domain)
- [x] 상품 정보를 수정한다.
  - [x] 상품 정보는 포인트 적립비율, 포인트 적립 가능여부를 포함한다.

- [x] 유저는 적립금을 가질 수 있다.
  - [x] 유저에 대한 적립금 조회 요청 시, 보유한 적립금을 반환한다. 

- [x] 장바구니에 담은 상품을 주문할 수 있다.
  - [x] 상품은 적립금에 대한 정보를 가진다.
    - [x] 적립금을 가질 수 있다.
      - [x] 최대 사용 가능한 적립금보다 사용하고자 하는 적립금이 크다면 예외를 발생시킨다.
      - [x] 적립금을 계산할 때, 소수 첫째 자리에서 반올림한다.
    - [x] 적립금을 가지지 않을 수도 있다.
  - [x] 상품 ID 목록을 통해 주문을 발행한다.
  - [x] 사용한 포인트가 있다면, 사용자 포인트에서 차감한다. 

- [x] 사용자 별로 주문 목록을 확인할 수 있다.

- [x] 사용자 별로 특정 주문의 상세 정보를 확인할 수 있다.


<details>
<summary> 고민 기록 </summary>
<div>

## STEP 1 고민
- [x] `Product`라는 도메인 객체에 Boolean 타입 프로퍼티가 들어가가 됨(`pointAvailable`)
  - [x] 그렇다면 이는 객체 분리의 시점이라는 것인데, 분리를 하면 영속화/복원은 어떻게 할까?
  - [x] 테이블 구조를 변경해야 할까? 그렇다면 현재 DB가 고정되어 있는 상황에서는 불가능한걸까?
- [x] 테이블 조인을 한다면 Repository와 Dao가 둘 다 필요하지 않다. 
  - [x] 조인된 결과 자체가 도메인 엔티티이기 때문에.
  - [x] 그렇다면 DAO, Repository가 둘 다 존재해야 하는 시점은 언제인가?
- [x] 조인 쿼리를 작성하다보니, 메소드가 엄청나게 길어지고 도메인 객체를 복원하는 코드도 복잡함.
  - [x] 하지만 성능 측면에서는 조인이 나을 것 같은데, 어플리케이션 레벨에서 조인을 수행해야 할 때는 언제일까?
- [x] `OrderInfoPersistenceAdapter`의 경우 package-private으로 두었음.
  - [x] `OrderInfo`는 `Order`라는 개념 하위에서만 존재한다. 단독으로 다뤄지는 경우는 없다.
  - [x] 그래서 외부에서 접근하지 못하도록 package-private으로 두어 `OrderPersistenceAdapter`가 접근하게 했는데, 좋은 방법일까?
- [x] 응답 JSON에서 키 값은 getter명을 따라가는 것 같다.
  - [x] 이에 대해 추후에 조금 더 공부해보기.
- [x] service에서 표현 계층의 request를 받는 형태로 작업하고 있음.
  - [x] 하지만, 표현 계층의 DTO를 사용하는 경우 service 내부 private 메소드에는 침투시키면 안될 것 같다는 생각.
  - [x] 양방향 의존성을 어느정도 용납하고 DTO를 그대로 받아와 쓰는 것인데... private 메소드까지 DTO를 침투시키면 결합도가 너무 높다.
  - [x] 따라서 `서비스 메소드의 첫줄에서 DTO를 변환시킨다!`라는 이야기가 나오는 듯 함.
- [x] `Order` 안에 `Member`가 존재하고, 로직을 도메인 객체 내에 캡슐화시키니 `Order`를 저장할 때 `Member`도 저장이 되어야 함.
  - [x] 즉, 객체들끼리 연관관계 + 상태 변경 로직을 가지게 되니 함께 저장해야 하는 문제가 생긴다.
  - [x] 이것이 애그리거트 단위로 분리하고, 저장하는 이유일까?
- [x] 클라이언트와 협업하기 시작하면서, 앞으로 예외 메세지는 어떻게 활용해야 할까?
  - [x] 디버깅적 측면이 굉장히 강해졌는데, user-friendly한 문구를 적을 필요가 있을까? 
  - [x] 기술적인 문구(ex. `리스트의 몇번째 인덱스에서 예외가 발생했습니다`) 를 작성하는게 낫지 않을까?
- [x] 이번 미션에서 가장 많이 한 고민 -> 이 로직은 서비스에 위치해야 하는가?
  - [x] 도메인이 수행할 수 있는가? 도메인이 수행할 수 있다면 모두 도메인 엔티티에 집어넣음
  - [x] 그렇게 되면 서비스는 영속화/복원, 순서 조정 등의 작업만 담당하게 됨.
- [x] 영속성에서 발생하는 예외는 커스텀 예외로 전환해야 할까?
  - [x] Spring에서는 `DataAccessException`의 하위 예외 중 하나로 전환해준다.
  - [x] 그런데 상태코드는 어떻게 지정할까? 데이터베이스 예외는 모두 500으로 넘겨줘야 할까? 유저의 불찰로 인한 무결성 제약조건 위반이라면?
- [x] 항상 모든 데이터를 서버가 가지고 있는 구조는 효율적이지 않음.
  - [x] 그래서 이번에는 프론트엔드에서 적립될 포인트를 먼저 계산해 렌더링하고, 이를 서버에 보내 일치하는지 확인하는 프로세스가 들어갔음.
  - [x] 이 경우 서비스에서 예외처리가 진행되는데 서비스에서 프론트엔드에 대한 어떠한 가정을 하고 있게 됨. 이를 어떻게 해결할 수 있을까?

</div>
</details>

<details>
<summary> 리팩토링 기록 </summary>
<div>

- [x] `ArgumentResolver` 내에서 빈 주입을 직접 받도록 변경
  - [x] 유지보수성 향상
  - [x] 모든 의존관계를 Config 파일에서 정의해줄 필요가 없기 때문
- [x] 도메인 엔티티 패키지 application 외부로 이동
  - [x] 도메인 패키지는 어플리케이션의 핵심이고, 별도의 패키지로 두는게 낫다
- [x] default profile 설정
  - [x] application.yml 에서 deafult profile로 무엇을 사용할지 지정
  - [x] 인텔리제이에서도 profile을 지정할 수 있지만, 모든 환경에서 공통적으로 profile을 지정하게 하려면 따로 properties 명시하자!
- [x] 개발 환경, 테스트 환경 DB URL 분리
  - [x] 현재야 테스트 환경이나 개발 환경이나 in-memory DB를 사용하므로 문제가 없다.
  - [x] 추후에 개발용 서버(MySQL 등)을 사용한다면 문제가 될 수 있을 듯 함.
  - [x] 테스트용 DB, 개발용 DB는 항상 따로 두는 연습을 하자.
- [x] 예외도 계층화를 시도했음.
  - [x] presentation 예외, application 예외를 나눔. 
  - [x] 이점은? 경계를 꿰뚫는 개념을 가지는 예외가 존재하지 않는다는 것. 계층 간의 격리를 더욱 강화시킨다.
  - [x] 단점은? 아무래도 관리 비용.
  - [x] 데이터베이스 예외의 경우(`DataAccessException` 하위 예외) 복구 불가능한 예외이므로 그대로 사용해도 될 듯 함.
    - [x] 굳이 커스텀 예외로 예외 전환을 시켜줄 필욘 없는 듯 하다.
- [x] 하나의 서비스에 여러 도메인이 존재하니 문제가 발생함.
  - [x] Member에 대한 상태 변경이 MemberService에서 이루어지고 있지 않다.
  - [x] 도메인이 어디서 변경되는지 추적이 힘듬.
- [x] Bean Validation을 통한 DTO 검증 수행
- [x] spring-logback.xml 을 통해 로깅 레벨에 따라 다른 파일에 저장되도록 함
  - [x] `debug` 레벨의 경우 커스텀 필터를 만들어서 스프링 내부, cart 패키지 내부에서 발생한 예외만 기록
  - [x] `error` 레벨의 경우 추가적으로 다른 로그파일에 저장.

</div>
</details>
